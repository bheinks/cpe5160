C51 COMPILER V9.53.0.0   SD                                                                10/12/2018 03:32:52 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE SD
OBJECT MODULE PLACED IN SD.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE SD.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include "SD.h"
   2          #include "SPI.h"
   3          #include "STDIO.H"
   4          #include "PORT.h"
   5          
   6          sbit green = P2^7;
   7          sbit orange = P2^6;
   8          sbit yellow = P2^5;
   9          sbit red = P2^4;
  10          
  11          uint8_t send_command(uint8_t command, uint32_t argument)
  12          {
  13   1          uint8_t rec_value, argument_LSB, argument_byte1, argument_byte2, argument_MSB, command_end, return_val
             -ue, error_flag;
  14   1          
  15   1          // check if CMD value is valid (less than 64)
  16   1          if(command < 64){
  17   2              return_value = NO_ERROR;
  18   2          }
  19   1          else{
  20   2              return_value = ILLEGAL_COMMAND;
  21   2              return return_value;
  22   2          }
  23   1          
  24   1          // append start and transmission bits to the 6 bit command
  25   1          command |= 0x40;
  26   1          
  27   1          // set commandend based on necessary CRC7 and end bit
  28   1          if(command == 0x40){      // CMD0
  29   2              command_end = 0x95;
  30   2          }
  31   1          else if(command == 0x48){ // CMD8
  32   2              command_end = 0x87;
  33   2          }
  34   1          else{                    // all other commands require no checksum
  35   2              command_end = 0x01;
  36   2          }
  37   1          
  38   1          // split argument into 4 bytes
  39   1          argument_LSB = argument & 0xFF;
  40   1          argument_byte1 = (argument >> 8) & 0xFF;
  41   1          argument_byte2 = (argument >> 16) & 0xFF;
  42   1          argument_MSB = (argument >> 24) & 0xFF;
  43   1          
  44   1          // send 6 byte command while checking for errors
  45   1          error_flag = SPI_transfer(command, &rec_value);
  46   1          if(error_flag != NO_ERROR){
  47   2              return_value = SPI_ERROR;
  48   2              return return_value;
  49   2          }
  50   1          
  51   1          error_flag = SPI_transfer(argument_MSB, &rec_value);
  52   1          if(error_flag != NO_ERROR){
  53   2              return_value = SPI_ERROR;
  54   2              return return_value;
C51 COMPILER V9.53.0.0   SD                                                                10/12/2018 03:32:52 PAGE 2   

  55   2          }    
  56   1          
  57   1          error_flag = SPI_transfer(argument_byte2, &rec_value);
  58   1          if(error_flag != NO_ERROR){
  59   2              return_value = SPI_ERROR;
  60   2              return return_value;
  61   2          }    
  62   1          
  63   1          error_flag = SPI_transfer(argument_byte1, &rec_value);
  64   1          if(error_flag != NO_ERROR) {
  65   2              return_value = SPI_ERROR;
  66   2              return return_value;
  67   2          }    
  68   1          
  69   1          error_flag = SPI_transfer(argument_LSB, &rec_value);
  70   1          if(error_flag != NO_ERROR){
  71   2              return_value = SPI_ERROR;
  72   2              return return_value;
  73   2          }    
  74   1          
  75   1          error_flag = SPI_transfer(command_end, &rec_value);
  76   1          if(error_flag != NO_ERROR){
  77   2              return_value = SPI_ERROR;
  78   2              return return_value;
  79   2          }
  80   1          
  81   1          return return_value;
  82   1      }
  83          
  84          uint8_t receive_response(uint8_t num_bytes, uint8_t *byte_array)
  85          {
  86   1          uint8_t SPI_val, count, error_flag, response;
  87   1          response = NO_ERROR;
  88   1          count = 0;
  89   1      
  90   1          // Keep transmitting until a response is received or timeout occurs
  91   1              do
  92   1          {
  93   2              error_flag = SPI_transfer(0xFF, &SPI_val);
  94   2              count++;
  95   2          }while(((SPI_val&0x80) == 0x80) && (error_flag == NO_ERROR) && (count != 0));
  96   1               
  97   1              // Error handling
  98   1          if (error_flag != NO_ERROR)
  99   1          {
 100   2              response = SPI_ERROR;
 101   2              printf("SPI_ERROR\n");
 102   2          }
 103   1              else if (count == 0)
 104   1          {
 105   2                      response = TIMEOUT_ERROR;
 106   2              printf("TIMEOUT_ERROR\n");
 107   2          }
 108   1              else if ((SPI_val&0xFE) != 0x00)
 109   1          {
 110   2              *byte_array = SPI_val;
 111   2              response = COMM_ERROR;
 112   2              printf("COMM_ERROR\n");
 113   2          }
 114   1             
 115   1              // No errors found
 116   1              else
C51 COMPILER V9.53.0.0   SD                                                                10/12/2018 03:32:52 PAGE 3   

 117   1              {
 118   2              *byte_array = SPI_val;
 119   2              if(num_bytes > 1) // If the response is greater than one byte
 120   2              {
 121   3                  for(count = 1; count < num_bytes; count++)
 122   3                  {
 123   4                      error_flag = SPI_transfer(0xFF, &SPI_val);
 124   4                      *(byte_array + count) = SPI_val;
 125   4                  }
 126   3              }
 127   2              else
 128   2              {
 129   3                response = COMM_ERROR;
 130   3                printf("COMM_ERROR2\n");
 131   3              }
 132   2          }
 133   1          error_flag = SPI_transfer(0xFF, &SPI_val);  // End with sending one last 0xFF out of the SPI port
 134   1                              
 135   1          return response;
 136   1      }
 137          
 138          uint8_t SD_card_init(void) {
 139   1          uint8_t index, receive_array[8], error_flag, timeout, return_value, i;
 140   1      
 141   1          timeout = 1; //initialize timeout variable
 142   1          
 143   1          printf("Initializing SD card...\n");
 144   1          
 145   1          // 74+ clock pulses on SCK with nCS high
 146   1          nCS0 = 1;
 147   1          for(index = 0; index < 10; ++index) {
 148   2              error_flag = SPI_transfer(0xFF, &return_value);
 149   2          }
 150   1          
 151   1          /************
 152   1          *
 153   1          *  command 0
 154   1          *
 155   1          *************/
 156   1          
 157   1          green = 0;
 158   1          
 159   1          
 160   1          nCS0 = 0;
 161   1          
 162   1          // Check for error
 163   1          if(error_flag != NO_ERROR){
 164   2              printf("SCK init error\n");
 165   2              return SD_INIT_ERROR;
 166   2          }
 167   1          
 168   1          //send CMD0 to SD card
 169   1          printf("CMD0 sent...\n");
 170   1          error_flag = send_command(CMD0, 0);
 171   1          
 172   1          //check for error
 173   1          if(error_flag != NO_ERROR){
 174   2              printf("CMD0 send error\n");
 175   2              return SD_INIT_ERROR;
 176   2          }
 177   1          
 178   1          //receive response from SD card
C51 COMPILER V9.53.0.0   SD                                                                10/12/2018 03:32:52 PAGE 4   

 179   1          error_flag=receive_response(1, receive_array);
 180   1          nCS0 = 1;
 181   1          
 182   1          printf("R1 Response expected\n");
 183   1          if(error_flag != NO_ERROR){
 184   2              printf("CMD0 receive error\n");
 185   2              return SD_INIT_ERROR;
 186   2          }
 187   1          else if(receive_array[0] != 0x01){
 188   2              printf("CMD0 response incorrect");
 189   2              printf("Response received: 0x");
 190   2              printf("%2.2Bx", receive_array[0]);
 191   2              printf("...\n");
 192   2              return SD_INIT_ERROR;
 193   2          }
 194   1          
 195   1          printf("Response received: 0x");
 196   1          printf("%2.2Bx", receive_array[0]);
 197   1          printf("...\n");
 198   1          
 199   1          /************
 200   1          *
 201   1          *  command 8
 202   1          *
 203   1          *************/
 204   1          
 205   1          nCS0 = 0;
 206   1          // Send CMD8 to SD card
 207   1          error_flag = send_command(CMD8, 0x000001AA);
 208   1          
 209   1          // Check for error
 210   1          if(error_flag != NO_ERROR){
 211   2              printf("CMD8 send error\n");
 212   2              return SD_INIT_ERROR;
 213   2          }
 214   1          
 215   1          // Receive response from SD card
 216   1          error_flag=receive_response(5, receive_array);
 217   1          nCS0 = 1;
 218   1          
 219   1          // Check for error
 220   1          if(error_flag != NO_ERROR){
 221   2              printf("CMD8 receive error\n");
 222   2              return SD_INIT_ERROR;
 223   2          }
 224   1          // Print results
 225   1          printf("R7 Response expected\n");
 226   1          if(receive_array[0] == 0x05){
 227   2              printf("Version 1 SD Card is Not Supported\n");
 228   2              return SD_INIT_ERROR;
 229   2          }
 230   1          else{
 231   2              printf("Version 2 Card Detected\n");
 232   2              printf("Response received: 0x");
 233   2              for(i=0;i<5;i++){
 234   3                  printf("%2.2Bx", receive_array[i]);
 235   3              }
 236   2              printf("...\n");
 237   2          }
 238   1          
 239   1          // Check for correct voltage
 240   1          if(receive_array[4] != 0x01){
C51 COMPILER V9.53.0.0   SD                                                                10/12/2018 03:32:52 PAGE 5   

 241   2              printf("CMD8 incorrect voltage error\n");
 242   2              return SD_INIT_ERROR;
 243   2          }
 244   1          
 245   1          // Check for matching check byte
 246   1          if(receive_array[5] != 0xAA){
 247   2              printf("CMD8 check byte mismatch\n");
 248   2              return SD_INIT_ERROR;
 249   2          }
 250   1          
 251   1          /************
 252   1          *
 253   1          *  CMD58
 254   1          *
 255   1          *************/
 256   1              
 257   1          nCS0 = 0;
 258   1          // Send CMD58 to SD card
 259   1          error_flag = send_command(CMD58, 0);
 260   1          
 261   1          // Check for error
 262   1          if(error_flag != NO_ERROR){
 263   2              printf("CMD58 send error\n");
 264   2              return SD_INIT_ERROR;
 265   2          }
 266   1          
 267   1          // Receive response from SD card
 268   1          error_flag=receive_response(5, receive_array);
 269   1          nCS0 = 1;
 270   1          
 271   1          // Check for error
 272   1          if(error_flag != NO_ERROR){
 273   2              printf("CMD58 receive error\n");
 274   2              return SD_INIT_ERROR;
 275   2          }
 276   1          
 277   1          // Print results
 278   1          printf("R3 Response expected\n");
 279   1          if((receive_array[2]&0xFC) != 0xFC){
 280   2              printf("CMD58 incorrect voltage error\n");
 281   2              return SD_INIT_ERROR;
 282   2          }
 283   1          else{
 284   2              printf("Response received: 0x");
 285   2              for(i=0;i<5;i++){
 286   3                  printf("%2.2Bx", receive_array[i]);
 287   3              }
 288   2              printf("...\n");
 289   2          }
 290   1          
 291   1          /************
 292   1          *
 293   1          *  ACMD41
 294   1          *
 295   1          *************/
 296   1              
 297   1          nCS0 = 0;
 298   1          // Send CMD55 to SD card
 299   1          error_flag = send_command(CMD55, 0);
 300   1          
 301   1          // Check for error
 302   1          if(error_flag != NO_ERROR){
C51 COMPILER V9.53.0.0   SD                                                                10/12/2018 03:32:52 PAGE 6   

 303   2              printf("CMD55 send error\n");
 304   2              return SD_INIT_ERROR;
 305   2          }
 306   1          
 307   1          // Receive response from SD card
 308   1          error_flag=receive_response(1, receive_array);
 309   1          nCS0 = 1;
 310   1          
 311   1          // Check for error
 312   1          if(error_flag != NO_ERROR){
 313   2              printf("CMD55 receive error\n");
 314   2              return SD_INIT_ERROR;
 315   2          }
 316   1          
 317   1          // Sending command ACMD41 until the R1 response is 0 or a timeout occurs
 318   1          while(receive_array[0] != 0){
 319   2              
 320   2              // Send ACMD41 to SD card
 321   2              error_flag = send_command(ACMD41, 0x40000000);
 322   2          
 323   2              // Check for error
 324   2              if(error_flag != NO_ERROR){
 325   3                  printf("ACMD41 send error\n");
 326   3                  return SD_INIT_ERROR;
 327   3              }
 328   2          
 329   2              // Receive response from SD card
 330   2              error_flag=receive_response(1, receive_array);
 331   2          
 332   2              // Check for error
 333   2              if(error_flag != NO_ERROR){
 334   3                  printf("ACMD41 receive error\n");
 335   3                  return SD_INIT_ERROR;
 336   3              }
 337   2              
 338   2              // Incriment timeout and check to see if it has reloaded
 339   2              timeout++;
 340   2              if(timeout == 0){
 341   3                  printf("ACMD41 timeout error\n");
 342   3                  return SD_INIT_ERROR;
 343   3              }
 344   2              
 345   2              nCS0 = 1;
 346   2              
 347   2          }
 348   1          
 349   1          // Print results
 350   1          printf("Response received: 0x");
 351   1          printf("%2.2Bx", receive_array[0]);
 352   1          printf("...\n");
 353   1      
 354   1          /************
 355   1          *
 356   1          *  CMD58 Again
 357   1          *
 358   1          *************/
 359   1              
 360   1          nCS0 = 0;
 361   1          // Send CMD58 to SD card
 362   1          error_flag = send_command(CMD58, 0);
 363   1          
 364   1          // Check for error
C51 COMPILER V9.53.0.0   SD                                                                10/12/2018 03:32:52 PAGE 7   

 365   1          if(error_flag != NO_ERROR){
 366   2              printf("CMD58 send error\n");
 367   2              return SD_INIT_ERROR;
 368   2          }
 369   1          
 370   1          // Receive response from SD card
 371   1          error_flag=receive_response(5, receive_array);
 372   1          nCS0 = 1;
 373   1          
 374   1          // Check for error
 375   1          if(error_flag != NO_ERROR){
 376   2              printf("CMD58 receive error\n");
 377   2              return SD_INIT_ERROR;
 378   2          }
 379   1          
 380   1          // Print results
 381   1          printf("R3 Response expected\n");
 382   1          if((receive_array[1]&0x80) != 0x80){
 383   2              printf("CMD58 card not in active state error\n");
 384   2              return SD_INIT_ERROR;
 385   2          }
 386   1          else if(receive_array[1]&0xC0 == 0xC0){
 387   2              printf("High capacity card accepted");
 388   2              printf("Response received: 0x");
 389   2              for(i=0;i<5;i++){
 390   3                  printf("%2.2Bx", receive_array[i]);
 391   3              }
 392   2              printf("...\n");
 393   2          }
 394   1          else{
 395   2              printf("High capacity card not detected error");
 396   2              return SD_INIT_ERROR;
 397   2          }
 398   1              
 399   1          printf("Initialization of SD card complete...\n");
 400   1          
 401   1          return NO_ERROR;
 402   1      }
 403          
 404          uint8_t read_block(uint16_t num_bytes, uint8_t * byte_array) {
 405   1          uint8_t SPI_val, count, error_flag, response;
 406   1          
 407   1          response = NO_ERROR;
 408   1          count = 0;
 409   1          
 410   1          // keep transmitting until a response is received or timeout occurs
 411   1              do {
 412   2              error_flag = SPI_transfer(0xFF, &SPI_val);
 413   2              count++;
 414   2          } while (((SPI_val & 0x80) == 0x80) && (error_flag == NO_ERROR) && (count != 0));
 415   1          
 416   1          // error handling
 417   1          if (error_flag != NO_ERROR) {
 418   2              response = SPI_ERROR;
 419   2          }
 420   1              else if (count == 0) {
 421   2                      response = TIMEOUT_ERROR;
 422   2          }
 423   1              else if ((SPI_val & 0xFE) != 0x00) {
 424   2              *byte_array = SPI_val;
 425   2              response = COMM_ERROR;
 426   2          }
C51 COMPILER V9.53.0.0   SD                                                                10/12/2018 03:32:52 PAGE 8   

 427   1          else {
 428   2              count = 0;
 429   2              
 430   2              // wait for data token
 431   2              do {
 432   3                  error_flag = SPI_transfer(0xFF, &SPI_val);
 433   3                  count++;
 434   3              } while ((SPI_val == 0xFF) && (error_flag == NO_ERROR) && (count != 0));
 435   2              
 436   2              if (error_flag != NO_ERROR) {
 437   3                  response = SPI_ERROR;
 438   3              }
 439   2              else if (count == 0) {
 440   3                  response = TIMEOUT_ERROR;
 441   3              }
 442   2              else if (SPI_val == 0xFE) {
 443   3                  for (count = 0; count < num_bytes; ++count) {
 444   4                      error_flag = SPI_transfer(0xFF, &SPI_val);
 445   4                      *(byte_array + count) = SPI_val;
 446   4                  }
 447   3                  
 448   3                  // discard CRC
 449   3                  error_flag = SPI_transfer(0xFF, &SPI_val);
 450   3                  error_flag = SPI_transfer(0xFF, &SPI_val);
 451   3              }
 452   2              else {
 453   3                  response = DATA_ERROR;
 454   3              }
 455   2          }
 456   1          
 457   1          // return to standby state
 458   1          error_flag = SPI_transfer(0xFF, &SPI_val);
 459   1          
 460   1          return response;
 461   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1405    ----
   CONSTANT SIZE    =    736    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      41
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
