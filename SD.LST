C51 COMPILER V9.53.0.0   SD                                                                10/12/2018 14:45:20 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE SD
OBJECT MODULE PLACED IN SD.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE SD.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include "SD.h"
   2          #include "SPI.h"
   3          #include <STDIO.H>
   4          #include "PORT.h"
   5          
   6          sbit green = P2^7;
   7          sbit orange = P2^6;
   8          sbit yellow = P2^5;
   9          sbit red = P2^4;
  10          
  11          uint8_t send_command(uint8_t command, uint32_t argument)
  12          {
  13   1          uint8_t rec_value, argument_LSB, argument_byte1, argument_byte2, argument_MSB, command_end, return_val
             -ue, error_flag;
  14   1          
  15   1          // check if CMD value is valid (less than 64)
  16   1          if(command < 64){
  17   2              return_value = NO_ERROR;
  18   2          }
  19   1          else{
  20   2              return_value = ILLEGAL_COMMAND;
  21   2              return return_value;
  22   2          }
  23   1          
  24   1          // append start and transmission bits to the 6 bit command
  25   1          command |= 0x40;
  26   1          
  27   1          // set commandend based on necessary CRC7 and end bit
  28   1          if(command == 0x40){      // CMD0
  29   2              command_end = 0x95;
  30   2          }
  31   1          else if(command == 0x48){ // CMD8
  32   2              command_end = 0x87;
  33   2          }
  34   1          else{                    // all other commands require no checksum
  35   2              command_end = 0x01;
  36   2          }
  37   1          
  38   1          // split argument into 4 bytes
  39   1          argument_LSB = argument & 0xFF;
  40   1          argument_byte1 = (argument >> 8) & 0xFF;
  41   1          argument_byte2 = (argument >> 16) & 0xFF;
  42   1          argument_MSB = (argument >> 24) & 0xFF;
  43   1          
  44   1          // send 6 byte command while checking for errors
  45   1          error_flag = SPI_transfer(command, &rec_value);
  46   1          if(error_flag != NO_ERROR){
  47   2              return_value = SPI_ERROR;
  48   2              return return_value;
  49   2          }
  50   1          
  51   1          error_flag = SPI_transfer(argument_MSB, &rec_value);
  52   1          if(error_flag != NO_ERROR){
  53   2              return_value = SPI_ERROR;
  54   2              return return_value;
C51 COMPILER V9.53.0.0   SD                                                                10/12/2018 14:45:20 PAGE 2   

  55   2          }    
  56   1          
  57   1          error_flag = SPI_transfer(argument_byte2, &rec_value);
  58   1          if(error_flag != NO_ERROR){
  59   2              return_value = SPI_ERROR;
  60   2              return return_value;
  61   2          }    
  62   1          
  63   1          error_flag = SPI_transfer(argument_byte1, &rec_value);
  64   1          if(error_flag != NO_ERROR) {
  65   2              return_value = SPI_ERROR;
  66   2              return return_value;
  67   2          }    
  68   1          
  69   1          error_flag = SPI_transfer(argument_LSB, &rec_value);
  70   1          if(error_flag != NO_ERROR){
  71   2              return_value = SPI_ERROR;
  72   2              return return_value;
  73   2          }    
  74   1          
  75   1          error_flag = SPI_transfer(command_end, &rec_value);
  76   1          if(error_flag != NO_ERROR){
  77   2              return_value = SPI_ERROR;
  78   2              return return_value;
  79   2          }
  80   1          
  81   1          return return_value;
  82   1      }
  83          
  84          uint8_t receive_response(uint8_t num_bytes, uint8_t *byte_array)
  85          {
  86   1          uint8_t SPI_val, count, error_flag, response;
  87   1          response = NO_ERROR;
  88   1          count = 0;
  89   1      
  90   1          // Keep transmitting until a response is received or timeout occurs
  91   1              do
  92   1          {
  93   2              error_flag = SPI_transfer(0xFF, &SPI_val);
  94   2              count++;
  95   2              green = 0;
  96   2          }while(((SPI_val&0x80) == 0x80) && (error_flag == NO_ERROR) && (count != 0));
  97   1              green = 1;
  98   1              // Error handling
  99   1          if (error_flag != NO_ERROR)
 100   1          {
 101   2              response = SPI_ERROR;
 102   2              printf("SPI_ERROR\n");
 103   2          }
 104   1              else if (count == 0)
 105   1          {
 106   2                      response = TIMEOUT_ERROR;
 107   2              printf("TIMEOUT_ERROR\n");
 108   2          }
 109   1              else if ((SPI_val&0xFE) != 0x00)
 110   1          {
 111   2              *byte_array = SPI_val;
 112   2              response = COMM_ERROR;
 113   2              printf("COMM_ERROR\n");
 114   2          }
 115   1             
 116   1              // No errors found
C51 COMPILER V9.53.0.0   SD                                                                10/12/2018 14:45:20 PAGE 3   

 117   1              else
 118   1              {
 119   2              *byte_array = SPI_val;
 120   2              if(num_bytes > 1) // If the response is greater than one byte
 121   2              {
 122   3                  for(count = 1; count < num_bytes; count++)
 123   3                  {
 124   4                      error_flag = SPI_transfer(0xFF, &SPI_val);
 125   4                      *(byte_array + count) = SPI_val;
 126   4                  }
 127   3              }
 128   2              else
 129   2              {
 130   3                response = COMM_ERROR;
 131   3                printf("COMM_ERROR2\n");
 132   3              }
 133   2          }
 134   1          error_flag = SPI_transfer(0xFF, &SPI_val);  // End with sending one last 0xFF out of the SPI port
 135   1                              
 136   1          return response;
 137   1      }
 138          
 139          uint8_t SD_card_init(void) {
 140   1          uint8_t index, receive_array[8], error_flag, timeout, return_value, i, error_message;
 141   1      
 142   1          timeout = 1; //initialize timeout variable
 143   1          
 144   1          printf("Initializing SD card...\n");
 145   1          
 146   1          // 74+ clock pulses on SCK with nCS high
 147   1          nCS0 = 1;
 148   1          for(index = 0; index < 10; ++index) {
 149   2              error_flag = SPI_transfer(0xFF, &return_value);
 150   2          }
 151   1          
 152   1          /************
 153   1          *
 154   1          *  command 0
 155   1          *
 156   1          *************/
 157   1          
 158   1          green = 0;
 159   1          
 160   1          
 161   1          
 162   1          
 163   1          // Check for error
 164   1          if(error_flag != NO_ERROR){
 165   2              printf("SCK init error\n");
 166   2              return SD_INIT_ERROR;
 167   2          }
 168   1          
 169   1          //send CMD0 to SD card
 170   1          printf("CMD0 sent...\n");
 171   1          nCS0 = 0;
 172   1          error_flag = send_command(CMD0, 0);
 173   1          orange = 0;
 174   1          //check for error
 175   1          if(error_flag != NO_ERROR){
 176   2              error_message = SEND_ERROR;
 177   2          }
 178   1          
C51 COMPILER V9.53.0.0   SD                                                                10/12/2018 14:45:20 PAGE 4   

 179   1          //receive response from SD card
 180   1          error_flag=receive_response(1, receive_array);
 181   1          nCS0 = 1;
 182   1          yellow = 0;
 183   1          printf("R1 Response expected\n");
 184   1          if(error_flag != NO_ERROR){
 185   2              if(error_message == SEND_ERROR){
 186   3                  printf("CMD0 send error\n");
 187   3              }
 188   2              else{
 189   3              printf("CMD0 receive error\n");
 190   3              }
 191   2              return SD_INIT_ERROR;
 192   2          }
 193   1          else if(receive_array[0] != 0x01){
 194   2              printf("CMD0 response incorrect");
 195   2              printf("Response received: 0x");
 196   2              printf("%2.2Bx", receive_array[0]);
 197   2              printf("...\n");
 198   2              return SD_INIT_ERROR;
 199   2          }
 200   1          
 201   1          printf("Response received: 0x");
 202   1          printf("%2.2Bx", receive_array[0]);
 203   1          printf("...\n");
 204   1          green = 0;
 205   1          /************
 206   1          *
 207   1          *  command 8
 208   1          *
 209   1          *************/
 210   1          
 211   1          nCS0 = 0;
 212   1          // Send CMD8 to SD card
 213   1          error_flag = send_command(CMD8, 0x000001AA);
 214   1          
 215   1          // Check for error
 216   1          if(error_flag != NO_ERROR){
 217   2              printf("CMD8 send error\n");
 218   2              return SD_INIT_ERROR;
 219   2          }
 220   1          
 221   1          // Receive response from SD card
 222   1          error_flag=receive_response(5, receive_array);
 223   1          nCS0 = 1;
 224   1          
 225   1          // Check for error
 226   1          if(error_flag != NO_ERROR){
 227   2              printf("CMD8 receive error\n");
 228   2              return SD_INIT_ERROR;
 229   2          }
 230   1          // Print results
 231   1          printf("R7 Response expected\n");
 232   1          if(receive_array[0] == 0x05){
 233   2              printf("Version 1 SD Card is Not Supported\n");
 234   2              return SD_INIT_ERROR;
 235   2          }
 236   1          else{
 237   2              printf("Version 2 Card Detected\n");
 238   2              printf("Response received: 0x");
 239   2              for(i=0;i<5;i++){
 240   3                  printf("%2.2Bx", receive_array[i]);
C51 COMPILER V9.53.0.0   SD                                                                10/12/2018 14:45:20 PAGE 5   

 241   3              }
 242   2              printf("...\n");
 243   2          }
 244   1          
 245   1          // Check for correct voltage
 246   1          if(receive_array[4] != 0x01){
 247   2              printf("CMD8 incorrect voltage error\n");
 248   2              return SD_INIT_ERROR;
 249   2          }
 250   1          
 251   1          // Check for matching check byte
 252   1          if(receive_array[5] != 0xAA){
 253   2              printf("CMD8 check byte mismatch\n");
 254   2              return SD_INIT_ERROR;
 255   2          }
 256   1          
 257   1          /************
 258   1          *
 259   1          *  CMD58
 260   1          *
 261   1          *************/
 262   1              
 263   1          nCS0 = 0;
 264   1          // Send CMD58 to SD card
 265   1          error_flag = send_command(CMD58, 0);
 266   1          
 267   1          // Check for error
 268   1          if(error_flag != NO_ERROR){
 269   2              printf("CMD58 send error\n");
 270   2              return SD_INIT_ERROR;
 271   2          }
 272   1          
 273   1          // Receive response from SD card
 274   1          error_flag=receive_response(5, receive_array);
 275   1          nCS0 = 1;
 276   1          
 277   1          // Check for error
 278   1          if(error_flag != NO_ERROR){
 279   2              printf("CMD58 receive error\n");
 280   2              return SD_INIT_ERROR;
 281   2          }
 282   1          
 283   1          // Print results
 284   1          printf("R3 Response expected\n");
 285   1          if((receive_array[2]&0xFC) != 0xFC){
 286   2              printf("CMD58 incorrect voltage error\n");
 287   2              return SD_INIT_ERROR;
 288   2          }
 289   1          else{
 290   2              printf("Response received: 0x");
 291   2              for(i=0;i<5;i++){
 292   3                  printf("%2.2Bx", receive_array[i]);
 293   3              }
 294   2              printf("...\n");
 295   2          }
 296   1          
 297   1          /************
 298   1          *
 299   1          *  ACMD41
 300   1          *
 301   1          *************/
 302   1              
C51 COMPILER V9.53.0.0   SD                                                                10/12/2018 14:45:20 PAGE 6   

 303   1          nCS0 = 0;
 304   1          // Send CMD55 to SD card
 305   1          error_flag = send_command(CMD55, 0);
 306   1          
 307   1          // Check for error
 308   1          if(error_flag != NO_ERROR){
 309   2              printf("CMD55 send error\n");
 310   2              return SD_INIT_ERROR;
 311   2          }
 312   1          
 313   1          // Receive response from SD card
 314   1          error_flag=receive_response(1, receive_array);
 315   1          nCS0 = 1;
 316   1          
 317   1          // Check for error
 318   1          if(error_flag != NO_ERROR){
 319   2              printf("CMD55 receive error\n");
 320   2              return SD_INIT_ERROR;
 321   2          }
 322   1          
 323   1          // Sending command ACMD41 until the R1 response is 0 or a timeout occurs
 324   1          while(receive_array[0] != 0){
 325   2              
 326   2              // Send ACMD41 to SD card
 327   2              error_flag = send_command(ACMD41, 0x40000000);
 328   2          
 329   2              // Check for error
 330   2              if(error_flag != NO_ERROR){
 331   3                  printf("ACMD41 send error\n");
 332   3                  return SD_INIT_ERROR;
 333   3              }
 334   2          
 335   2              // Receive response from SD card
 336   2              error_flag=receive_response(1, receive_array);
 337   2          
 338   2              // Check for error
 339   2              if(error_flag != NO_ERROR){
 340   3                  printf("ACMD41 receive error\n");
 341   3                  return SD_INIT_ERROR;
 342   3              }
 343   2              
 344   2              // Incriment timeout and check to see if it has reloaded
 345   2              timeout++;
 346   2              if(timeout == 0){
 347   3                  printf("ACMD41 timeout error\n");
 348   3                  return SD_INIT_ERROR;
 349   3              }
 350   2              
 351   2              nCS0 = 1;
 352   2              
 353   2          }
 354   1          
 355   1          // Print results
 356   1          printf("Response received: 0x");
 357   1          printf("%2.2Bx", receive_array[0]);
 358   1          printf("...\n");
 359   1      
 360   1          /************
 361   1          *
 362   1          *  CMD58 Again
 363   1          *
 364   1          *************/
C51 COMPILER V9.53.0.0   SD                                                                10/12/2018 14:45:20 PAGE 7   

 365   1              
 366   1          nCS0 = 0;
 367   1          // Send CMD58 to SD card
 368   1          error_flag = send_command(CMD58, 0);
 369   1          
 370   1          // Check for error
 371   1          if(error_flag != NO_ERROR){
 372   2              printf("CMD58 send error\n");
 373   2              return SD_INIT_ERROR;
 374   2          }
 375   1          
 376   1          // Receive response from SD card
 377   1          error_flag=receive_response(5, receive_array);
 378   1          nCS0 = 1;
 379   1          
 380   1          // Check for error
 381   1          if(error_flag != NO_ERROR){
 382   2              printf("CMD58 receive error\n");
 383   2              return SD_INIT_ERROR;
 384   2          }
 385   1          
 386   1          // Print results
 387   1          printf("R3 Response expected\n");
 388   1          if((receive_array[1]&0x80) != 0x80){
 389   2              printf("CMD58 card not in active state error\n");
 390   2              return SD_INIT_ERROR;
 391   2          }
 392   1          else if(receive_array[1]&0xC0 == 0xC0){
 393   2              printf("High capacity card accepted");
 394   2              printf("Response received: 0x");
 395   2              for(i=0;i<5;i++){
 396   3                  printf("%2.2Bx", receive_array[i]);
 397   3              }
 398   2              printf("...\n");
 399   2          }
 400   1          else{
 401   2              printf("High capacity card not detected error");
 402   2              return SD_INIT_ERROR;
 403   2          }
 404   1              
 405   1          printf("Initialization of SD card complete...\n");
 406   1          
 407   1          return NO_ERROR;
 408   1      }
 409          
 410          uint8_t read_block(uint16_t num_bytes, uint8_t * byte_array) {
 411   1          uint8_t SPI_val, count, error_flag, response;
 412   1          
 413   1          response = NO_ERROR;
 414   1          count = 0;
 415   1          
 416   1          // keep transmitting until a response is received or timeout occurs
 417   1              do {
 418   2              error_flag = SPI_transfer(0xFF, &SPI_val);
 419   2              count++;
 420   2          } while (((SPI_val & 0x80) == 0x80) && (error_flag == NO_ERROR) && (count != 0));
 421   1          
 422   1          // error handling
 423   1          if (error_flag != NO_ERROR) {
 424   2              response = SPI_ERROR;
 425   2          }
 426   1              else if (count == 0) {
C51 COMPILER V9.53.0.0   SD                                                                10/12/2018 14:45:20 PAGE 8   

 427   2                      response = TIMEOUT_ERROR;
 428   2          }
 429   1              else if ((SPI_val & 0xFE) != 0x00) {
 430   2              *byte_array = SPI_val;
 431   2              response = COMM_ERROR;
 432   2          }
 433   1          else {
 434   2              count = 0;
 435   2              
 436   2              // wait for data token
 437   2              do {
 438   3                  error_flag = SPI_transfer(0xFF, &SPI_val);
 439   3                  count++;
 440   3              } while ((SPI_val == 0xFF) && (error_flag == NO_ERROR) && (count != 0));
 441   2              
 442   2              if (error_flag != NO_ERROR) {
 443   3                  response = SPI_ERROR;
 444   3              }
 445   2              else if (count == 0) {
 446   3                  response = TIMEOUT_ERROR;
 447   3              }
 448   2              else if (SPI_val == 0xFE) {
 449   3                  for (count = 0; count < num_bytes; ++count) {
 450   4                      error_flag = SPI_transfer(0xFF, &SPI_val);
 451   4                      *(byte_array + count) = SPI_val;
 452   4                  }
 453   3                  
 454   3                  // discard CRC
 455   3                  error_flag = SPI_transfer(0xFF, &SPI_val);
 456   3                  error_flag = SPI_transfer(0xFF, &SPI_val);
 457   3              }
 458   2              else {
 459   3                  response = DATA_ERROR;
 460   3              }
 461   2          }
 462   1          
 463   1          // return to standby state
 464   1          error_flag = SPI_transfer(0xFF, &SPI_val);
 465   1          
 466   1          return response;
 467   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1423    ----
   CONSTANT SIZE    =    736    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      42
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
